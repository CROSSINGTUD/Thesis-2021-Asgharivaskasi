\cryptoapibench{} is the first benchmark that we utilized to evaluate \cognicryptsast and \codyze. In this section, we will first discuss the \cryptoapibench{} and the types of misuses it covers. Following the discussion of experiment execution, we examine the results of the analyses of \cryptoapibench{} using \codyze{} and \cognicryptsast. 

According to Afrose \etal  \cite{cryptoapibench}, \cryptoapibench{} provides 171 cases for assessing the quality of various cryptographic vulnerability detection tools. \cryptoapibench{} addresses 16 different types of cryptographic and SSL/TLS API misuse vulnerabilities. These include hardcoded secrets, improper certificate validations, improper hostname validations, insecure symmetric and asymmetric cryptographic primitives, and insecure hash functions \cite{cryptoapibench}. The \cryptoapibench{} consists of 40 basic tests, 131 advanced tests, which includes 40 inter-procedural, 19 field-sensitive, 20 combined tests (combination of inter-procedural and field-sensitive), and 20 path-sensitive test cases \cite{cryptoapibench}.

Each of these 16 categories of misuses of cryptographic APIs is regarded by the \cryptoapibench{} as a cryptographic threat model, and each threat model has a corresponding cryptographic API \cite{cryptoapibench}. The \cryptoapibench{} provides test cases for which neither \codyze{} nor \cognicryptsast{} provides rules for the corresponding APIs, namely, javax.net.ssl.HostnameVerifier, javax.net.ssl.X509TrustManager, javax.net.ssl.SSLSocket, and java.net.URL. Therefore, we do not consider the threat models related to those APIs in our evaluation because both tools did not identify any misuses in those models. We will only use the remaining 12 threat models that are shown in the Table \ref{tab:cryptobench}. The following is a brief explanation of these 12 threat models presented by \cryptoapibench{} in order to gain an understanding of the type of vulnerability they introduce.

\emph{Cryptographic Key}. When using a key generated by the javax.crypto.spec.SecretKeySpec API for encryption, the Byte array that SecretKeySpec takes as input should be unpredictable and not constant or hard-coded. Otherwise, the attacker could easily read the key to obtain sensitive information. 

\emph{Passwords in PBE (Password-based Encryption)}. It relates to the use of a constant or hardcoded password in the javax.crypto.spec.PBEKeySpec API to generate a SecretKey. A hardcoded or constant password may allow an attacker to acquire it and gain access to the key.

\emph{Passwords in KeyStore}. The java.security.KeyStore API is used to store cryptographic keys or certificates. The KeyStore requires a password to access the stored keys, which should not be hardcoded or a constant. Otherwise, the keys and certificates stored in the KeyStore could be accessed by unauthorized parties.

\emph{Pseudorandom Number Generator (PRNG)}. The random number generator algorithm used by java.util.Random (Knuth's subtractive \cite{sok}) is proven to be insecure, while java.security.SecureRandom generates a random number that is non-deterministic and unpredictable. Therefore, it is recommended to use SecureRandom instead of Random because the latter does not produce a completely random number.

\emph{Seeds in Pseudorandom Number Generator (PRNG)}. When using SecureRandom to generate random numbers, we may encounter the same random number in every run if we use a constant or not randomly generated seed as SecureRandom's parameter.

\emph{Salts in Password-based encryption (PBE)}. Javax.crypto.spec.PBEParameterSpec API takes the salt and iteration count when setting parameters for Password-based encryption. Salt should not be hardcoded, or a constant but rather should be randomly generated. Otherwise, it may result in producing an insecure key.
 
\emph{Mode of Operation}. ECB (Electronic Codebook) is not considered a secure mode of operation in javax.crypto.Cipher since it does not conceal data patterns well and may disclose information about the plaintext. CBC or Galois/Counter (GCM) Mode should be used instead.

\emph{Initialization Vector (IV)}. To enhance cryptography security, initialization vectors (IVs) are used during encryption and decryption. A constant/static initialization vector may introduce vulnerabilities. Therefore, it is recommended to use a random initialization vector in the crypto.spec.IvParameterSpec API.

\emph{Iteration Count in Password-based Encryption (PBE)}. For Password-based Encryption (PBE) with the javax.crypto.spec.PBEParameterSpec API, it requires salt and iteration count. The Public Key Cryptography Standards (PKCS), which is a set of public-key cryptography standards published by RSA Security LLC (an American company that focuses on encryption and encryption standards \cite{rsa}) #5 version 2.0 \cite{pbeiteration}, recommends that the number of iterations should be greater than 1000 to provide adequate security. Therefore, iteration counts less than 1000 are considered insecure. 

\emph{Symmetric Ciphers}. Symmetric cryptography employs the same key for both encryption and decryption. AES is the preferred symmetric cipher, as several other symmetric ciphers, including DES, Blowfish, RC4, RC2, IDEA, and RC4, are considered broken.

\emph{Asymmetric Ciphers}. In asymmetric cryptography, a pair of keys, including a public key and a private key, is used to encrypt and decrypt data. It is, however, recommended to use 2048 bit key size for some asymmetric ciphers, such as RSA, because they are considered broken with 1024 bit key size.

\emph{Cryptographic Hash Functions}. In cryptography, hash functions convert an arbitrary message to a fixed-size value known as a hash or message digest, which is utilized to verify message integrity, digital signature, and authentication. When two inputs of the same cryptographic hash function produce the same hash value, it is considered to be broken. SHA-256 is an alternative to insecure hash functions such as SHA1, MD4, MD5, and MD2.


\subsection{Description of the execution of the experiment}

To collect analysis results, we analyzed the \cryptoapibench{} source code with \cognicryptsast{} Eclipse plugin by triggering the start button and analyzing the entire project, and with \codyze{} Eclipse plugin by opening all the class files in the Eclipse editor. As JCA is the most commonly used cryptographic library for Java \cite{snb16}, we chose to use the JCA rulesets. However, the \MARK{} developers did not provide rules for the JCA API, so we used \crysl{} rules for the JCA API \cite{apirules} in \cogcnicryptsast{} and \MARK{} rules for Bouncy Castle API \cite{codyzegit} in \codyze.

The Misuses that \codyze{} finds in a program in Eclipse are not displayed with a red flag except for the misuses related to the forbidden methods. They are instead displayed as information, such as when a \MARK{} rule is verified. This made it difficult to distinguish between violations and verifications of \codyze's findings in Eclipse and increased the risk of mistakes occurring when collecting the analyses results. In our meeting with a \codyze{} developer, they mentioned that the problem lies within the file \code{CpgDocumentService.java}\footnote{\url{https://github.com/Fraunhofer-AISEC/codyze/blob/main/src/main/java/de/fraunhofer/aisec/codyze/crymlin/connectors/lsp/CpgDocumentService.java}} . After \codyze{} has gathered all findings in a program, it categorizes their severity level into three categories: information, warning, and error. Nevertheless, it does not identify misuses within the error category; instead, misuses are considered information, which is the default severity level.

After performing the analysis, we obtained the true positives and false positives based on the results logs of each tool. Since our goal is to compare the cryptographic vulnerability detection of the two tools, we considered only cryptographic misuse alerts and disregard unrelated information. When a tool generates an alert based on the correct reason in a vulnerable test case, it is considered a true positive (TP). If in a correct test case of a threat model, a tool identifies a misuse related to that threat model, then it is considered as a false positive (FP).


% true positive is when the analysis identified a misuse that exists, and true negative is when the analysis does not indicate a misuse where one did not occur.


\subsection{Examining the results of analyses}

In the following, we describe the results of evaluating the \cryptoapibench{} with each detection tool and compare their performances. Table \ref{tab:cryptobench} presents the number of true positives (TP) and false positives (FP) detections of vulnerabilities by the \codyze{} and \cognicryptsast{} in the 12 cryptographic threat models in \cryptoapibench{} that we previously discussed. In this context, true positive is when a tool detects misuse in a test case, and it is a vulnerability based on the CryptoAPI-Bench\_details.xlsx file available on \cryptoapibench's Github page \cite{benchgithub}. This Excel file provides an overview of secure and non-secure code as well as the vulnerabilities. Further, a false positive is when a tool identifies a misuse in a test case with no vulnerability based on the Excel file. TTP stands for total true positives, the number of test cases with vulnerabilities provided by the \cryptoapibench. TTN stands for total true negatives, the number of test cases provided by \cryptoapibench{} with the correct usages of cryptographic APIs. TTN and TTP are calculated based on the Excel file. The last two columns in Table \ref{tab:cryptobench}, indicate the recall and precision of \codyze{} and \cognicryptsast{} when analyzing each threat model. Pre and Rec are acronyms for precision and recall, respectively.

\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcommand\mc[1]{\multicolumn{1}{c}{#1}}
\newcommand\mC[1]{\multicolumn{1}{C}{#1}}
\begin{table}[hp]
 \begin{adjustwidth}{-1em}{} 
%  \captionsetup{justification=centering}
\setlength\tabcolsep{3.3pt} 
\small
\centering
\begin{tabular}{|c|l|c|c|c|c|}
 \hline
 No.& Threat Models & TTP & TTN & 
 \begin{tabular}{cccc}
    \multicolumn{4}{c}{\codyze{}}\\
    TP&FP&{\hskip 0.2in}Pre(\%)&Rec(\%)\\
\end{tabular}
&
\begin{tabular}{cccc}
    \multicolumn{4}{c}{\cognicryptsast{}}\\
    TP&FP&Pre(\%)&Rec(\%)\\
\end{tabular} \\

 \hline
 \hline
1& Cryptographic Key& 8 & 2 & 0 {\hskip 0.15in} 0 {\hskip 0.5in} 0{\hskip 0.4in} 0 & 8 {\hskip 0.2in} 2 {\hskip 0.2in} 80,00 {\hskip 0.2in} 100\\
2& Password in PBE & 8 & 3&0 {\hskip 0.15in} 0 {\hskip 0.5in} 0{\hskip 0.4in} 0 & {\hskip 0.1in}6 {\hskip 0.2in} 5 {\hskip 0.2in} 54,54 {\hskip 0.2in} 75,00\\
3&Password in KeyStore & 7& 3& 0 {\hskip 0.15in} 0 {\hskip 0.5in}  0{\hskip 0.4in} 0 & {\hskip 0.1in}6 {\hskip 0.2in} 2 {\hskip 0.2in} 75,00 {\hskip 0.2in} 85,71\\
4& PRNG  & 1& 1& 0{\hskip 0.2in} 0 {\hskip 0.5in} 0 {\hskip 0.35in} 0{\hskip 0.065in}& 0{\hskip 0.25in} 0 {\hskip 0.45in} 0 {\hskip 0.3in} 0{\hskip 0.3in}\\
5& Seed in PRNG  & 14&3 &0 {\hskip 0.15in} 0 {\hskip 0.5in} 0 {\hskip 0.35in} 0 & 0{\hskip 0.25in} 0 {\hskip 0.45in} 0 {\hskip 0.3in} 0{\hskip 0.3in}\\
6& Salt in PBE  & 7&2 & 0 {\hskip 0.15in} 0 {\hskip 0.5in}  0{\hskip 0.4in} 0 & 7 {\hskip 0.2in} 2 {\hskip 0.2in} 77,77 {\hskip 0.2in} 100\\
7& Mode of Operation  & 6&2 &{\hskip 0.05in}1 {\hskip 0.2in} 1 {\hskip 0.3in} 50,00{\hskip 0.15in} 16,66 &{\hskip 0.1in}5 {\hskip 0.2in} 1 {\hskip 0.2in} 83,33 {\hskip 0.2in} 83,33\\
8& Initialization Vector  & 8&2& 8 {\hskip 0.2in} 2 {\hskip 0.3in} 80,00{\hskip 0.2in} 100 & 8 {\hskip 0.2in} 0 {\hskip 0.3in} 100 {\hskip 0.2in} 100\\
9& Iteration Count in PBE & 7&2& 0 {\hskip 0.2in} 0 {\hskip 0.5in} 0{\hskip 0.4in} 0 &{\hskip 0.1in} 5 {\hskip 0.2in} 2 {\hskip 0.2in} 71,42 {\hskip 0.2in} 71,42\\
10& Symmetric Cipher& 30&6& 30 {\hskip 0.15in} 6 {\hskip 0.3in} 83,33{\hskip 0.2in} 100 & {\hskip 0.1in}20 {\hskip 0.2in} 5 {\hskip 0.2in} 80,00 {\hskip 0.2in} 66,66\\
11& Asymmetric Ciphers & 5& 1& 0 {\hskip 0.2in} 0 {\hskip 0.5in} 0{\hskip 0.4in} 0 & {\hskip 0.1in}4 {\hskip 0.25in} 1 {\hskip 0.2in} 80,00 {\hskip 0.2in} 80,00\\
12& Cryptographic Hash  & 24&5& 24 {\hskip 0.15in} 4 {\hskip 0.3in} 85,71{\hskip 0.2in} 100 & {\hskip 0.1in}20 {\hskip 0.2in} 4 {\hskip 0.2in} 83,33 {\hskip 0.2in} 83,33\\

 \hline
 \multicolumn{2}{|l|}{\textbf{Total}} & 125 & 32& {\hskip 0.1in} 63 {\hskip 0.1in} 13 {\hskip 0.3in} \textbf{82,89} {\hskip 0.1in} \textbf{50,80} & {\hskip 0.1in} 89 {\hskip 0.15in} 24 {\hskip 0.2in} \textbf{78,76} {\hskip 0.1in} \textbf{71,20} {\hskip 0.3in}\\
%  \hline
%  \multicolumn{2}{|l|}{\multirow{2}{*}{ \textbf{Results}}} & \multicolumn{2}{|l|}{ \textbf{Precision(\%)}} &  \textbf{82,89} & \textbf{78,76} &-&-\\ 
%  \multicolumn{2}{|l|}{} & \multicolumn{2}{|l|}{ \textbf{Recall(\%)}} &  \textbf{50,80}&  \textbf{71,20}& -&-\\ 
 \hline

\end{tabular}
\caption{\label{tab:cryptobench} Comparison of \codyze{} and \cognicryptsast{} analysis on 12 threat models in \cryptoapibench{}'s 171 test cases.}
\end{adjustwidth}
\end{table}

Based on the Table \ref{tab:cryptobench}, there are 10 models of cryptographic threads that are covered by \cognicryptsast, while \codyze{} covers 4 models. From 125 vulnerable test cases, \codyze{} identified 63 and \cognicryptsast{} identified 89 true positives. \codyze{} and \cognicryptsast{} generate a total of 13 and 24 false alarms (false positives), respectively. In test cases related to the SecureRandom API (threat models 4 and 5 in the Table \ref{tab:cryptobench}), \cognicryptsast{} does not detect any misuses, despite the fact that this type of misuse is explicitly specified by the SecureRandom \crysl{} rule of JCA APIs. This is clearly a false negative. \codyze{} does not detect any misuses for the models 1 to 6 and 9 and 11. It is because there are no \MARK{} rules to specify those vulnerabilities. 

As we mentioned before in Section \ref{sec:codyze}, \MARK{} developers wrote \MARK{} rules based on BSI \cite{BSI} TR-02102-1 version 2019-01. The 2019-01 version of BSI TR-02102-1 is not publicly available; therefore, we contacted the BSI and asked for that version to verify that all the specifications of cryptographic APIs described therein are implemented as \MARK{} rules. We received 2019-01 version \cite{bsi19} very late in the thesis timeline, and unfortunately, it was in German. We requested the English version but did not receive it when this thesis was written. However, we were able to check the rules with the help of translation tools and the latest version of BSI TR-02102-1 (version 2021-01) \cite{bsiTR}.  In some cases, the rules in the BSI could not be described as \MARK{} rules because \MARK{} maintainers could not interpret them in \MARK{} or Bouncy Castle (the API for which the \MARK{} rules are written) did not provide the implementation for that rule.

For example, in section 2.1.2 (Betriebsbedingungen) of the BSI guideline, it is stated that the initialization vectors must not be repeated during the lifetime of a key, i.e., they should not be used for two different ciphers at the same time. Because it requires sufficient knowledge about the program's dynamic behavior, the \MARK{} developers were unable to define it as a \MARK{} rule; however, it is not clear whether this rule is included in the analysis. Another example is section 3.5 (RSA), which is related to the RSA Cipher and indicates that the size of the modulus in calculating the key length of the RSA Cipher must be at least 2000. It cannot be defined in \MARK{} since we cannot adequately reason about the modulus of the RSA key.


The Table \ref{tab:cryptobench} indicates that \codyze{} has a higher precision than \cognicryptsast{}, which means that it can identify misuses that \cognicryptsast{} cannot detect. Meanwhile, \cognicryptsast{} has a better recall than \codyze, which indicates that \cognicryptsast{} has identified more misuses than \codyze, likely because \codyze{} does not cover all threat models as it lacks the \MARK{} rules that specify cryptographic misuses in the missing models. 

The only case in which \codyze{} could not detect all misuses was in the mode of operation (number 7 in the Table \ref{tab:cryptobench}) model. In only one of the test cases, \codyze{} was able to identify an incorrect mode of Cipher. In the other test cases involving such misuse, \codyze{} detected an invalid Cipher rather than an invalid mode of Cipher, which is a false positive.

According to the \crysl{} rule for the class PBEKeySpec of JCA API (see Listing \ref{lst:orgpbecryslRule}), the iteration count should be more than 10000; whereas, based on \cryptoapibench, iteration counts higher than 1000 are acceptable. One of the false positives in the \cognicryptsast{} results for the ninth threat model was caused by this difference.

It should also be noted that \codyze{} and \cognicryptsast{} produce false positives for misuses that are not listed in the threat model of \cryptoapibench. For instance, \cognicryptsast{} identifies a misuse that indicates that the key used by Cipher is not generated correctly as a generatedKey. It occurred in every test case containing a Cipher object with a Key parameter. This is a true positive for the cases where the key is generated with an improper algorithm or key size, but for the cases where a key is properly generated based on the \crysl{} rules, this is a false positive. Nine of the test cases contain this false positive. This issue has already been reported to \cognicryptsast's Github page\footnote{https://github.com/eclipse-cognicrypt/CogniCrypt/issues/457}. 

In addition to the misuses specified by \cryptoapibench{}, \codyze{} and \cognicryptsast{} also detect other misuses in the benchmark. If the provider of an API is not specified, \codyze{} throws a provider error. According to the \MARK{} rules, the provider should always be specified so that APIs used in the code and the API of \MARK{} ruleset used to analyze, have the same provider such as the Bouncy Castle provider. For example, in the mode of operation threat model, \codyze{} detected that there was no provider specified when using the Cipher and KeyGenerator APIs. All the provider misuses discovered by \codyze{} were true positives. Additionally, there were errors detected by \codyze{} concerning calls to java.security.SecureRandom that were forbidden. The findings were also true positives according to the \MARK{} rule for the SecureRandom from the Bouncy Castle API. The forbidden calls are shown in Lines \ref{line:forbidpbe1} and \ref{line:forbidpbe2} of Listing \ref{lst:orgsecureRandomMARK}.
Another finding by \codyze{} was that padding was not applied to the RSA cipher. Based on the \MARK{} rules for Cipher, RSA Cipher must always have a padding (proper paddings are specified in the rule). Therefore \codyze{} found such misuses and they are true positives. According to Naccache \etal \cite{rsapadding}, it is necessary to apply encryption padding in order to prevent dictionary attacks. A dictionary attack is a type of brute force attack in which a hacker uses a list of common words and phrases to attempt to crack a password-protected security system. Furthermore, there was an error related to the Cipher order, as the order in which the Cipher methods were called did not comply with the \MARK{} order rule for Cipher (true positive). The same error was generated more than once within the same test case, which was redundant and unnecessary. 

\cognicryptsast{} detects misuses that are not included in the \cryptoapibench's benchmark, namely invalid ordering of PBEKeySpec, MessageDigest, and Cipher.
Taking the \crysl{} rules for the JCA API into consideration, the order of Cipher error is a false positive, whereas the order of PBEKeySpec is the result of the absence of a call to the clearPassword method as the final call and is a true positive. The MessageDigest invalid order is also a true positive based on the \crysl{} rule.


Overall, \codyze's precision in detecting misuses is approximately 4 percent better than \cognicryptsast. However, when we consider the four threat models for which both tools had rules (threat models 7, 8, 10, and 12), we can observe that \cognicryptsast{} has a better accuracy for two of the models and \codyze{} has a better accuracy for the other two. Further, the difference between precisions is greater when \cognicryptsast's precision is higher (7 and 8), since \codyze{} usually produces more false positives than \cognicryptsast. Regarding the recall, \codyze{} does not provide sufficient \MARK{} rules to define cryptographic vulnerabilities of all threat models, and as a result, its recall value is 20 percent lower than that of \cognicryptsast. 




The next table (Table \ref{tab:cryptobenchadvanced}) shows the result of analyzing \cryptoapibench{} advanced test cases that both \codyze{} and \cognicryptsast{} have rules for the cryptographic APIs of their threat models. This includes the mode of operation (javax.crypto.Cipher), initialization vector (javax.crypto.spec.IvParameterSpec), symmetric cipher (javax.crypto.Cipher) and cryptographic Hash (java.security.MessageDigest). They are categorized into 7 categories that we shortly describe below.

In two-interprocedural cases, the source of vulnerability in one procedure is passed as an argument to the parameter of another procedure and then used in the crytographic API.
In three-interprocedural cases, the source of vulnerability is passed as an argument to another procedure and then passed again to the third procedure. These inter-procedural test cases measure the ability to handle the data flow. 

The field-sensitive cases check the ability of the tools in performing field-sensitive data flow analysis. Combined cases contain test cases with a combination of inter-proceural and field sensitivity. Path-sensitive test cases include conditional branches to examine the accuracy of determining the source of a vulnerability. Miscellaneous test cases are intended to assess the tool's ability to detect irrelevant constraints and other interfaces, such as Map. In multiple class test cases, the source of vulnerabilities that is originated in one class is passed to another class and used in a cryptographic API.


\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\begin{table}[H]
 \begin{adjustwidth}{-1em}{} 
\centering
\setlength\tabcolsep{3pt}
\small
\begin{tabular}{ |p{4cm}|P{1cm}|P{1cm}|P{5cm}|P{5cm}|}

 \hline
 Advanced Test Cases & TTP & TTN & \begin{tabular}{cccc}
    \multicolumn{4}{c}{\codyze{}}\\
    TP&FP&Pre(\%)&Rec(\%)\\
\end{tabular}&
\begin{tabular}{cccc}
    \multicolumn{4}{c}{\cognicryptsast{}}\\
    TP&FP&Pre(\%)&Rec(\%)\\
\end{tabular} \\

 \hline
 \hline
Two-Interprocedural&  11 & 0 &10 {\hskip 0.2in} 0 {\hskip 0.2in} 100{\hskip 0.2in} 90,90 & 11 {\hskip 0.2in} 0 {\hskip 0.2in} 100 {\hskip 0.2in} 100\\
Three-Interprocedural& 11  & 0& 10 {\hskip 0.2in} 0 {\hskip 0.2in} 100{\hskip 0.2in} 90,90 & 11 {\hskip 0.2in} 0 {\hskip 0.2in} 100 {\hskip 0.2in} 100\\
Field Sensitive& 11& 0& 10 {\hskip 0.2in} 0 {\hskip 0.2in} 100{\hskip 0.2in} 90,90 & {\hskip 0.1in}2 {\hskip 0.25in} 0 {\hskip 0.2in} 100 {\hskip 0.2in} 18,18\\
Combined Case& 11& 0&10 {\hskip 0.2in} 0 {\hskip 0.2in} 100{\hskip 0.2in} 90,90 & {\hskip 0.1in}1 {\hskip 0.25in} 0 {\hskip 0.2in} 100 {\hskip 0.25in} 9,09\\
Path Sensitive& 0&11 &0 {\hskip 0.2in} 11 {\hskip 0.3in} 0 {\hskip 0.4in} 0 {\hskip 0.2in}& 0 {\hskip 0.2in} 10 {\hskip 0.3in} 0 {\hskip 0.3in} 0{\hskip 0.4in}\\
Miscellaneous Cases& 2&0 &  2 {\hskip 0.3in} 0 {\hskip 0.2in} 100{\hskip 0.3in} 100{\hskip 0.4in} & 2 {\hskip 0.25in} 0 {\hskip 0.2in} 100 {\hskip 0.2in} 100\\
Multiple Class methods& 11&0 &10 {\hskip 0.2in} 0 {\hskip 0.2in} 100{\hskip 0.2in} 90,90 & 11 {\hskip 0.2in} 0 {\hskip 0.2in} 100 {\hskip 0.2in} 100\\

 \hline
 \textbf{Total} & 57 & 11& {\hskip 0.1in}52 {\hskip 0.2in} 11 {\hskip 0.15in} \textbf{82,53}{\hskip 0.1in} \textbf{91,22}{\hskip 0.1in} & {\hskip 0.15in}38 {\hskip 0.15in} 10 {\hskip 0.1in} \textbf{79,16} {\hskip 0.1in}\textbf{66,66}\\
 \hline
%  \multirow{2}{*}{ \textbf{Results}} & \multicolumn{2}{|l|}{ \textbf{Precision(\%)}} &  \textbf{82,53} & \textbf{79,16}&-&-\\ 
%   & \multicolumn{2}{|l|}{ \textbf{Recall(\%)}} &  \textbf{91,22}&  \textbf{66,66}&-&-\\

\end{tabular}
\caption{\label{tab:cryptobenchadvanced} Comparison of \codyze{} and \cognicryptsast{} analyses of \cryptoapibench's 68 advanced test cases (of all 12 threat models in Table \ref{tab:cryptobench}) that both tools have common corresponding cryptographic rules for them.}
\end{adjustwidth}
\end{table}

Table \ref{tab:cryptobenchadvanced} indicates that when we restrict the test cases to those for which both tools have rules that relate to them and are capable of analyzing them, then \codyze's recall increases to 91,22 percent. The only vulnerability that \codyze{} could not identify in the test cases is related to the mode of operation, as previously explained. If we examine the cases individually, \cognicryptsast{} provides better recall than \codyze, except in the field-sensitive and combined cases, in which \cognicryptsast{} detected only three misuses in 22 tests of field-sensitive and combined cases, whereas \codyze{} detected all of them. Therefore, we can conclude that \codyze{} is field-sensitive, and \cognicryptsast{} is partially field-sensitive. However, in Section \ref{sec:cc}, we learned that \cognicryptsast{} is field-sensitive. These results may be due to the fact that the \cryptoapibench{} test cases are biased in favor of \cryptoguard{} and are designed only to examine whether \cryptoguard{} is field-sensitive or not and therefore do not provide completely field-sensitive cases or are insufficient to analyze field sensitivity. It may also be due to \cognicryptsast{} being only partly field-sensitive. In order to ensure that, it is necessary to test more field-sensitive test cases or to verify that the field-sensitive test cases in \cryptoapibench{} address the field-sensitivity issue. Due to our limited time, we suggest performing this as a future work discussed in Chapter \ref{ch:fwork}.


\cognicryptsast{} detected all of the inter-procedural misuses, which makes it inter-procedural. \codyze{} found 10 of the 11 misuses in the inter-procedural test cases, making it partially inter-procedural. The fact that \codyze{} is inter-procedural is unexpected. As stated in section \ref{sec:codyze}, based on the \codyze{} Java docs and the fact that CPG is not inter-procedural, we concluded that \codyze{} is not inter-procedural. The contradiction may be because the \codyze{} Java documentation has not been updated yet, and \codyze{} is, in fact, inter-procedural, or it is the test cases problem. It is possible that the tests are not inter-procedural, or they are insufficient to determine if an analysis is inter-procedural. Our future work could include verifying that the inter-procedural tests of \cryptoapibench{} are indeed inter-procedural, and providing enough inter-procedural test cases to test the tools to determine if they are inter-procedural.

Both tools have the same precision in each of the advanced test cases separately, but overall \codyze{} produces one more false positive than \cognicryptsast{} (in the path-sensitive case). The path-sensitive case consists of 11 test cases that do not contain any misuses, and if the analyzer detects misuses in those 11 tests, then it is not path-sensitive. \codyze{} detected that all the correct test cases have misuses which indicates that \codyze{} is not path-sensitive.
\cognicryptsast{} found misuses in 10 out of 11 correct path-sensitive test cases, suggesting that \cognicryptsast{} is rarely path-sensitive. However, there is a possibility that \cognicryptsast{} did not find a misuse in this particular case by accident, since as mentioned in Section \ref{sec:cc}, \cognicryptsast is not path-sensitive. \cryptoapibench's test cases may not be sufficient in this case. As future work, we could use more path-sensitive test cases to verify whether the tools are path-sensitive or not.
\\

For similar misuses that both \codyze{} and \cognicryptsast{} detect, they produce different error messages. Table \ref{tab:errormsgs} presents the error messages that \codyze{} and \cognicryptsast{} produce for the misuses they found in four mutual threat models. As we mentioned previously, there is a JSON file (findingdescription.json) produced by the \codyze{} developers, which contains all the possible error messages (cf. section \ref{sec:codyze}), and \cognicryptsast{} generates the error messages based on the type of error (e.g., constraints, predicates, etc.), as we explained in the section \ref{sec:cc}. Therefore, \codyze{} always displays similar error messages when the same misuse occurs. As an example, it always generated the same error message for the incorrect Cipher as demonstrated in the Table \ref{tab:errormsgs} (symmetric cipher threat model). \codyze{} error messages are more abstract than \cognicryptsast{} error messages, as \codyze{} states the misuse of the API and the reason for its insecurity. \cognicryptsast{} error messages provide more details. For instance, in the mode of operation, symmetric cipher, and cryptographic hash, \cognicryptsast{} provides information for the appropriate algorithms, modes, and hashes to use, respectively. In the initialization vector, \codyze{} only mentions that the IV has an inadequate quality, whereas \cognicryptsast{} specifies that the IV needs to be a random number.

% \newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\begin{table}[H]
\centering

\begin{tabular}{*{3}{p{.32\linewidth}}}
% \caption{Long table caption.\label{long}}\\
 \hline
\diagbox{Threat Model}{Tool} & \codyze & \cognicryptsast \\
\hline
\toprule
Mode of Operation & Use of an unspecified cipher mode for symmetric-key algorithms: A cipher mode for symmetric-key algorithms was detected that does not match one of the recommended Cipher modes by BSI TR-02102. Use of weak or unspecified cipher modes may not guarantee sufficient security. & First parameter (with value \emph{"the parameter of cipher.getInstance(String)"}) should be any of the \emph{"{list of possible modes for that algorithm}"} \\\midrule
Initialization Vector& Insufficient quality of IV for CBC cipher mode: The IV used with the cipher mode CBC is not sufficiently unpredictable. Predictable IVs, which an attacker could guess, compromises the security 
 guarantees of CBC cipher mode.& First parameter was not properly generated as randomized\\\midrule
 
Symmetric Cipher& Use of an unspecified cipher: A cipher was detected that does not match one of the recommended ciphers by BSI TR-02102. Use of weak or unspecified ciphers may not guarantee sufficient security.& First parameter (with value \emph{"the parameter of cipher.getInstance(String)"}) should be any of \emph{"list of all valid parameter of cipher.getInstance(String)"}\\\midrule

Cryptographic Hash& Use of an unspecified hash function: An unspecified hash function is being used. Unspecified hash functions may be weak to attacks. & First parameter (with value \emph{"the parameter of MessageDigest.getInstance(String)"}) should be any of \emph{{list of all valid parameters of MessageDigest.getInstance(String)}}\\
\hline

\end{tabular}
\caption{\label{tab:errormsgs} Comparison of the error messages produced by \codyze{} and \cognicryptsast{} for the similar misuses they found after analyzing \cryptoapibench.}
\end{table}


In summary, overall \codyze{} achieved a higher level of precision than \cognicryptsast{} in analyzing \cryptoapibench{}, however \cognicryptsast{} covered more cryptographic vulnerabilities than \codyze. Therefore, when analyzing the test cases for which both tools have rules (Table \ref{tab:cryptobench}), \cognicryptsast's recall is noticeably higher than \codyze. \codyze{} analysis is context- and flow-sensitive, and partially field-sensitive and inter-procedural, but not path-sensitive. \cognicryptsast{} analysis is inter-procedural and context-sensitive and partially field-sensitive, but seldom path-sensitive.

Furthermore, \cognicryptsast{} produces more detailed error messages than \codyze. There are also some issues with both tools. \codyze{}, for instance, produced duplicate errors when the Cipher order was violated. \codyze{} did not generate any false positives other than those identified in analyzing \cryptoapibench{} in Tables \ref{tab:cryptobench} and \ref{tab:cryptobenchadvanced}. \cognicryptsast{} produces a false positive, that is related to the incorrect usage of the keyGenerator API, in several test cases. However, the misuses of the KeyGenerator API are not considered in the \cryptoapibench{} threat models. Therefore, we did not count them as false positives in the evaluation.

\cryptoapibench{} only covered a few cryptographic vulnerabilities, and the number of test cases they provided may not be sufficient for a fair comparison. Furthuremore, \cryptoapibench{} was created to evaluate \cryptoguard's ability to detect misuses in usages of Java cryptographic APIs, and may therefore be biased toward \cryptoguard. Consequently, we will evaluate \cognicryptsast{} and \codyze{} in the next section with the test cases generated by the \cognicrypttestgen.


% To calculate the runtime we analyzed the \cryptoapibench{} with \cogcnicryptsast{} and \codyze{} on the command line and calculated the time each tool took to generate the result of the analysis. to do so we generated a jar file of \cryptoapibench{} project via Eclipse export option. Based on the information provided on the \cryptoapibench{} Github page, we can build a jar file of \cryptoapibench's project. However, we could not build the jar file with that way due to an error. We have reported this issue on GitHub\footnote{https://github.com/CryptoGuardOSS/cryptoapi-bench/issues/4}. For analyzing \cryptoapibench{} with \codyze{} on the command line we just needed the path to the folder containing the test cases.