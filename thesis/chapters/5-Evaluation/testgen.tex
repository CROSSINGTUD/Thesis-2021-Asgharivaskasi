Results of the analysis in the last section may not provide us with a fair comparison since the number of test cases may not be sufficient to provide a meaningful comparison. Additionally, they do not cover all of the vulnerabilities covered by \codyze{} and \cognicryptsast, and the \cryptoapibench{} was designed to evaluate \cryptoguard's cryptographic misuse detection capability. Therefore, we propose to analyze the test cases generated by \cognicryptsast. Here, we discuss how we generated the test cases using \cognicrypttestgen, how we ran the experiment, calculated and recorded misuses, and finally, we discuss the results of the analyses.

With the help of a \cognicrypttestgen{} developer, we set up the source code of the \cognicrypttestgen{} Eclipse plugin and built it within Eclipse (Skype meeting with one of the \cognicrypttestgen{} developers on Nov 15, 2021). We used the unpublished version of \cognicrypttestgen{} on the evaluation branch\footnote{\url{https://github.com/CROSSINGTUD/CogniCrypt_TESTGEN/tree/evaluation}} to the date of October 31\textsubscript{st} 2021 to the commit e834927\footnote{\url{https://github.com/CROSSINGTUD/CogniCrypt_TESTGEN/commit/e8349276c172bae24b6e1016c309fcd2b5b5d761}}.

In order to generate test cases, \cognicrypttestgen{} utilizes \crysl{} rules. \cognicrypttestgen{} covers most sections in the \crysl{} rules completely, partially covers the ENSURED and CONSTRAINTS sections, and does not cover the FORBIDDEN and NEGATES sections \cite{rakshit}. The generated tests could be used as unit or integration tests \cite{rakshit}. We used them as integration tests in our case because several test cases generated by \cognicrypttestgen{} were incorrectly considered valid or invalid or included more than one misuse and therefore needed further examination.

We used \cognicrypttestgen{} to generate test cases covering all the \MARK{} and \crysl{} rules for the Bouncy Castle JCA and JCA APIs. Therefore, we used JCA and Bouncy Castle JCA \crysl{} rules and the translated Bouncy Castle \crysl{} rules that we created in Section \ref{sec:marktocrysl}. \cognicrypttestgen{} generated test cases for 38 Java cryptographic APIs with JCA \crysl{} rules (see Table \ref{appendix:jcatestcomp}), and it generated test cases for 38 Java cryptographic APIs with Bouncy Castle JCA \crysl{} rules (see Table \ref{tab:bctestcomp}). \cognicrypttestgen{} also generated test cases for 32 Java cryptographic APIs with translated Bouncy Castle \crysl{} rules. There are several valid and invalid test cases for each of those APIs. \cognicrypttestgen{} creates a valid test case for every complete sequence in the FSM (finite state machine) defined in the ORDER section with all the possible methods and parameters and creates an invalid test case for every incomplete sequence in the FSM. Therefore, in invalid test cases, the insecurity is the incorrect order of operators in the use of an API.

To simplify, we will refer to the test cases that \cognicrypttestgen{} generated from \crysl{} Bouncy Castle JCA ruleset as the Bouncy Castle tests and the test cases generated from the JCA \crysl{} ruleset as the JCA tests. Moreover, we refer to the test cases generated from the translated Bouncy Castle \crysl{} rules as the \MARK{} Bouncy Castle tests. In total, there are 228 valid and 233 invalid test cases in the JCA tests and 228 valid and 233 invalid test cases in the Bouncy Castle tests. Furthermore, there are 50 valid and 0 invalid test cases in the Bouncy Castle \MARK{} tests.


We encountered some errors when generating test cases with Bouncy Castle JCA \crysl{} rules, and the \cognicrypttestgen{} could not generate the test cases. We debugged the \cognicrypttestgen's source code and fixed it with the assistance of one of the \cognicrypttestgen's developers (Skype meeting with one of the \cognicrypttestgen{} developers on Nov 26, 2021). We provided a pull request to solve this issue\footnote{\url{https://github.com/CROSSINGTUD/CogniCrypt\_TESTGEN/pull/15}}.



\subsection{Description of the execution of the experiment}
We analyzed the test cases using both tools on the virtual machines as we described in the previous section (see Section \ref{sec:apibench}). Analyzing the test cases, we found that some of the valid test cases contained misuses, while some of the invalid test cases contained no misuses. The misuses in the valid test cases and the correct invalid test cases were detected by both tools. Some of them were detected by \cognicryptsast, and others by \codyze. We will tackle all misuses further when discussing the results. We checked the remaining test cases in which none of the tools detected API misuse manually to ensure there was no API misuse. We considered all the misuses that each tool found in the test cases (both valid and invalid) in the results of the analyses. Moreover, the total number of misuses (for calculating precision and recall) was calculated by measuring the union of the set of misuses found by both tools. We will discuss the calculation of true and false positives in detail in Sections \ref{sec:testgenbcresult} and \ref{sec:testgenmarkbcresult}.
We conducted eight analyses, four for each tool, as follows:
\begin{itemize}
  \item Analyzing Bouncy Castle tests using \codyze{} with Bouncy Castle \MARK{} rules and using \cognicryptsast{} with the translated Bouncy Castle \crysl{} rules.
  
  \item Analyzing Bouncy Castle tests using \codyze{} with translated Bouncy Castle JCA \MARK{} rules and using \cognicryptsast{} with Bouncy Castle JCA \crysl{} rules.
  
  \item Analyzing JCA tests using \codyze{} with translated JCA \MARK{} rules and using \cognicryptsast{} with JCA \crysl{} rules.
  
  \item Analyzing \MARK{} Bouncy Castle tests using \codyze{} with the Bouncy Castle \MARK{} rules and using \cognicryptsast{} with translated Bouncy Castle \crysl{} rules.

\end{itemize}
The true positives and false positives are calculated the same as in the previous section (see Section \ref{sec:apibench}).

\subsection{Examining the results of analyses}
Here, the results of all analyses are compared and discussed.
The \MARK{} Bouncy Castle tests consisted of 50 valid test cases and no invalid ones, with 9 of those 50 valid tests containing a compiler error (see Table \ref{appendix:markbctestcomp}). Consequently, when analyzing these test cases using \codyze{} with the Bouncy Castle \MARK{} rules and \cognicryptsast{} with the translated Bouncy Castle \crysl{} rules, the analysis results as shown in the Table \ref{appendix:markbctestcomp} in the Appendices indicate no misuses, except for the IvParameterSpec test cases. Two of the nine compiler errors occur in the two test cases for the IvParameterSpec API. Despite the compiler errors, \codyze{} detected two misuses in the IvParameterSpec tests, which were a result of the unspecified provider name of the SecureRandom API, which is a true positive (Listing \ref{lst:ivparammarktestgen} line \ref{line:secrandprovider}). \cognicryptsast{} did not detect any misuses in all the cases. Nevertheless, when we removed the erroneous lines from the IvParameterSpec test cases, including the Line \ref{line:faultyline} from Listing \ref{lst:ivparammarktestgen}, \cognicryptsast{} detected the provider misuses and produced two other errors that were related to this misuse. For example, on Line \ref{line:secrandprovider} of listing \ref{lst:ivparammarktestgen} the related error stated that the \code{secureRandom0} parameter was not appropriately generated as a random number, which is also a true positive. However, it is the same as provider misuse. We will discuss the dependent misuses more in Section \ref{sec:testgenbcresult}. Even though both analyses detected the same problem after the fix, this finding illustrates the capability of \codyze{} to analyze erroneous test cases. Since this test case does not provide any additional useful results, we will not discuss it further.

\begin{lstlisting}[language=Java, caption=A faulty test case from \MARK{} Bouncy Castle test, label={lst:ivparammarktestgen}, escapechar=|]
	public void ivParameterSpecValidTest2() throws NoSuchAlgorithmException, NoSuchProviderException {

		String algorithm = null;
		byte[] seed = null;
		int next = 0;
		String provider = null;
		SecureRandom secureRandom0 = SecureRandom.getInstance(algorithm, provider);|\label{line:secrandprovider}|
		secureRandom0.setSeed(seed);
		secureRandom0.next(next); |\label{line:faultyline}|
		int offset = 0;
		int len = 0;
		IvParameterSpec ivParameterSpec0 = new IvParameterSpec(seed, offset, len);

	}
\end{lstlisting}

In the following, we will examine the results of analyzing Bouncy Castle and JCA tests with \codyze{} and \cognicryptsast. The results of analyzing Bouncy Castle tests with Bouncy Castle \crysl{} rules (original and the translation into \MARK), and those of analyzing JCA tests with the JCA \crysl{} rules (original and the translation into \MARK) are similar. Therefore, we focus our discussion on only one of them but provide results for both in tables. Since the Bounce Castle tests provide more information and cover the results of analyses on JCA tests, we will discuss the results of analyzing the Bouncy Castle tests in greater detail. We can therefore divide the analyses results into two sections: first, the results of analyzing Bouncy Castle and JCA tests using \codyze{} and translated Bouncy Castle JCA and JCA \MARK{} rules, and using \cognicryptsast{} and Bouncy Castle JCA and JCA \crysl{} rules, and second, the results of analyzing Bouncy Castle tests using \codyze{} and Bouncy Castle \MARK{} rules, and using \cognicryptsast{} and translated Bouncy Castle \crysl{} rules.


\subsubsection{Discussing the results of analyzing Bouncy Castle and JCA tests using \codyze{} with translated Bouncy Castle JCA and JCA \MARK{} rules, and using \cognicryptsast{} with Bouncy Castle JCA and JCA \crysl{} rules}
\label{sec:testgenbcresult}

In this section, we discuss only the results of analyzing the Bouncy Castle tests generated by \cognicrypttestgen. Because the results of analyzing the two test cases were similar, we chose Bouncy Castle tests since they covered more misuses and contained the misuses in the JCA tests' results. 

Table \ref{tab:bctestcomp} presents the results of analyzing Bouncy Castle tests with \codyze{} and \cognicryptsast. Test name refers to the name of the API for which \cognicrypttestgen{} generated test cases. TP refers to the number of true positives. An error is a true positive when it is caused by a violation of a \crysl{} rule or its translation to \MARK. FP is the number of false positives. An error is a false positive when no violation of the corresponding \crysl{} rule or its translation into \MARK{} has occurred.


Valid tests and invalid tests columns indicate the number of valid and invalid test cases in each of the 38 test cases, according to the \cognicrypttestgen{} division of valid and invalid test cases. In total, there are 228 valid test cases and 233 invalid test cases in the Bouncy Castle tests. However, \codyze{} and \cognicryptsast{} discovered misuses in both valid and invalid test cases. The test cases generated by \cognicrypttestgen{} contained several misuses that were not intended to exist. Some test cases contained more than one misuse, therefore in some cases in the table, the number of true positives is greater than the number of test cases. For example, for the AlgorithmParameters API, there are nine valid test cases, and \codyze{} and \cognicryptsast{} both detected 18 misuses in all nine valid test cases. Therefore, we analyzed misuses that \codyze{} and \cognicryptsast{} detected based on \crysl{} rules and calculated the number of false positives and true positives.


\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcommand{\mytoprule}{\specialrule{0.1em}{0em}{0em}}
\newcommand{\mybottomrule}{\specialrule{0.1em}{0em}{0em}}
\begin{table}[H]
%  \begin{adjustwidth}{-9em}{} 
\centering
\setlength\tabcolsep{4.31pt}
\small
\begin{tabularx}{\textwidth}{|P{0.5cm}|l|x|x|x|x|}
 \hline
 No.&Test Name & \makecell{Valid \\ tests} & \makecell{Invalid \\ tests} & \begin{tabular}{cccc}
    \multicolumn{4}{c}{\codyze{}} \\
    \multicolumn{2}{c}{Valid} & \multicolumn{2}{c}{Invalid}
    \\TP&FP& TP & FP
\end{tabular} & \begin{tabular}{cccc}
    \multicolumn{4}{c}{\cognicryptsast{}}\\
    \multicolumn{2}{c}{Valid} & \multicolumn{2}{c}{Invalid}\\
    TP&FP&TP&FP

\end{tabular}\\

 \hline
 \hline
1&AlgorithmParameterGenerator&  5 & 9 & 3{\hskip 0.25in}2 {\hskip 0.15in} 12 {\hskip 0.2in} 2&3 {\hskip 0.2in}0 {\hskip 0.15in} 12 {\hskip 0.15in} 0\\
2&AlgorithmParameters& 9& 5& 9{\hskip 0.25in}11 {\hskip 0.15in} 5 {\hskip 0.2in} 5&18 {\hskip 0.15in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 0{\hskip 0.25in}\\
3&CertPathTrustManagerParameters& 1& 0& 0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
4&CipherInputStream& 3& 5& 3{\hskip 0.25in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 6 {\hskip 0.2in} 0\\
5&CipherOutputStream& 3&5 &3{\hskip 0.25in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 6 {\hskip 0.2in} 0 \\
6&Cipher& 56&69 & 40{\hskip 0.2in}21 {\hskip 0.1in} 72 {\hskip 0.15in} 0{\hskip 0.2in}&40 {\hskip 0.15in}13 {\hskip 0.15in} 90 {\hskip 0.1in} 25{\hskip 0.05in}\\
7&DHGenParameterSpec& 1&0 &1{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
8&DHParameterSpec&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
9&DigestInputStream&2&4 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}2 {\hskip 0.2in} 5 {\hskip 0.2in} 0\\
10&DigestOutputStream&2&4 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}2 {\hskip 0.2in} 5 {\hskip 0.2in} 0\\
11&DSAGenParameterSpec&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
12&DSAParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
13&ECGenParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
14&ECParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
15&GCMParameterSpec&2&0 &0{\hskip 0.25in}2 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
16&HMACParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
17&IvParameterSpec&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
18&KeyAgreement&7&23 &0{\hskip 0.25in}2 {\hskip 0.15in} 23 {\hskip 0.2in} 6&0 {\hskip 0.2in}0 {\hskip 0.15in} 23 {\hskip 0.2in} 0 \\
19&KeyFactory&6&0 &0{\hskip 0.25in}4 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
20&KeyGenerator&8&8 &0{\hskip 0.25in}3 {\hskip 0.2in} 8 {\hskip 0.2in} 3&0 {\hskip 0.2in}0 {\hskip 0.2in} 8 {\hskip 0.2in} 0\\
21&KeyManagerFactory&6&4 &0{\hskip 0.25in}8 {\hskip 0.2in} 4 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 4 {\hskip 0.2in} 0\\
22&KeyPairGenerator&6&10 &4{\hskip 0.25in}0 {\hskip 0.15in} 14 {\hskip 0.2in} 0&4 {\hskip 0.2in}0 {\hskip 0.15in} 12 {\hskip 0.2in} 0\\
23&KeyStoreBuilderParameters&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
24&KeyStore&13&21&0{\hskip 0.25in}0 {\hskip 0.15in} 17 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.15in} 17 {\hskip 0.2in} 0\\
25&Mac&12&21 &0{\hskip 0.25in}7 {\hskip 0.15in} 21 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.15in} 22 {\hskip 0.2in} 0\\
26&MessageDigest&9&13 &0{\hskip 0.25in}1 {\hskip 0.2in} 2 {\hskip 0.2in} 1&2 {\hskip 0.2in}0 {\hskip 0.2in} 8 {\hskip 0.2in} 0\\
27&MGF1ParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
28&OAEPParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
29&PBEKeySpec&1&1 &0{\hskip 0.25in}1 {\hskip 0.2in} 1 {\hskip 0.2in} 1&0 {\hskip 0.2in}0 {\hskip 0.2in} 1 {\hskip 0.2in} 0\\
30&PBEParameterSpec&2&0 &0{\hskip 0.25in}1 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
31&PKIXBuilderParameters&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
32&PKIXParameters&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
33&RSAKeyGenParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
34&SecretKeyFactory&3&2 &0{\hskip 0.25in}4 {\hskip 0.2in} 2 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 2 {\hskip 0.2in} 0\\
35&SecureRandom&38&16 &3{\hskip 0.25in}0 {\hskip 0.2in} 3 {\hskip 0.2in} 0&0 {\hskip 0.2in}2 {\hskip 0.2in} 0 {\hskip 0.2in} 7\\
36&SSLContext&5&5&10{\hskip 0.2in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 0&10 {\hskip 0.15in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 0\\
37&SSLParameters&4&4 &0{\hskip 0.25in}1 {\hskip 0.2in} 4 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 3 {\hskip 0.2in} 0\\
38&TrustManagerFactory&6&4 &0{\hskip 0.2in}13 {\hskip 0.2in} 4 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 4 {\hskip 0.2in} 0\\
 \hline
 \hline
 \multicolumn{2}{|l|}{ \textbf{Total}} &  \textbf{228} & \textbf{233} & 76 {\hskip 0.1in} 81{\hskip 0.2in} 207 {\hskip 0.1in}18 &  85{\hskip 0.1in} 19{\hskip 0.2in} 238{\hskip 0.1in} 32\\
 \hline
 \multicolumn{2}{|l|}{\multirow{2}{*}{\textbf{Results}}}
 &   \multicolumn{2}{|l|}{\textbf{Precision(\%)}} &74,08 & 86,36\\ 
 
 \multicolumn{2}{|l|}{} & \multicolumn{2}{|l|}{\textbf{Recall(\%)}} & 85,75 & 97,87 \\
 \hline

\end{tabularx}
\caption{\label{tab:bctestcomp} Comparison of the results of \codyze{} and \cognicryptsast{} analyses of Bouncy Castle tests generated by \cognicrypttestgen.}
% \end{adjustwidth}
\end{table}

% in most of the cases the amount of true positives are similar except for the cipher where there is a big difference between codyze findings and cognicryptsast findings.
\cognicryptsast{} generates misuses that depend upon other misuses.
For instance, both tools have found misuses in the following code in listing \ref{lst:ciphertestgen}. \cognicryptsast{} detects four misuses that are all true positives in this test case, and \codyze{} finds three misuses that are also true positives.
The tools have two common misuses. First, on line \ref{line:wrongsize}, the parameter of AlgorithmParameterGenerator's \code{init} method must be in any of 128, 192, 256 bits and not 1048 bits. Second, the Cipher algorithm should not be RSA. In addition, \cognicryptsast{} identifies two more misuses on Line \ref{line:wrongorder} that are caused by the first two misuses. The error indicates that the second parameter (\code{secretKey}) was not properly generated as a generated key, which is correct since the algorithms used in Cipher and KeyGenerator are different. The other error states that the third parameter (\code{algorithmParameters}) was not generated properly, which is also true due to the incorrect parameter used in the AlgorithmParameterGenerator. The dependent errors will be resolved by correcting the first two misuses. We have found more dependent errors in other cipher test cases but none in other test cases. \codyze{} detects another misuse that \cognicryptsast{} does not, which is the incorrect order of Cipher in Line \ref{line:wrongorder}. This misuse is caused by the fact that the Cipher has not been terminated properly, and a final call is required.


We counted the true positives for Cipher without the dependent errors in the Table \ref{tab:bctestcomp}. If we count the dependent misuses, then \cognicryptsast{} finds 71 true positives in the valid Cipher tests and 104 true positives in the invalid tests, which contain many duplicate errors. Therefore, we did not include the dependent errors when calculating precision and recall.
% as it appears in the table \ref{tab:bctestcomp}, both tools produce several false positives in the Cipher test cases. most of these false positives relate to the order misuses. 

Suppose we only count the misuses caused by incorrect order of operations, as shown in the Table \ref{appendix:bctestcomporder} in the appendices. In that case, we can see that \codyze{} performed better in finding order misuses than \cognicryptsast{} in the Cipher test cases. If we calculate the precision and recall just for the Cipher test case for all valid and invalid cases, \codyze{} achieves 72,72\% precision and 100\% recall, and \cognicryptsast{} achieves 67,14 \% precision and 83,92 \% recall, which indicates that in this case, \codyze{} performs better than \cognicryptsast. The overall precisions of \cognicryptsast{} and \codyze{} were very similar; however, \codyze's recall was about 3 percent higher, indicating that it was more effective in finding order misuses.


\begin{lstlisting}[language=Java, caption=One of the valid test cases for the Cipher API that \cognicrypttestgen{} generated from the original \crysl{} Bouncy Castle JCA ruleset., label={lst:ciphertestgen}, escapechar=|]
	public void cipherValidTest7() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, InvalidAlgorithmParameterException {

		KeyGenerator keyGenerator0 = KeyGenerator.getInstance("AES");
		SecretKey secretKey = keyGenerator0.generateKey();

		AlgorithmParameterGenerator algorithmParameterGenerator0 =                   AlgorithmParameterGenerator.getInstance("AES");
		algorithmParameterGenerator0.init(1048);|\label{line:wrongsize}|
		AlgorithmParameters algorithmParameters = algorithmParameterGenerator0.generateParameters();

		Cipher cipher0 = Cipher.getInstance("RSA"); |\label{line:wrongalg}|
		cipher0.init(1, secretKey, algorithmParameters); |\label{line:wrongorder}|
	}
\end{lstlisting} 

\cognicryptsast{} detects some misuses that \codyze{} does not, and therefore the number of true positives for \cognicryptsast{} in some cases are more than \codyze. Those misuses are related to the constraints error. As an example, in the Cipher \crysl{} rule in the CONSTRAINTS section, it is stated that the input length of the Cipher object must be greater than 0. In the Listing \ref{lst:partciphtestgen} Line \ref{line:conscipher}, the third parameter, which is the input length, is zero; therefore it is a misuse, which \cognicryptsast{} identified. However, \codyze{} does not detect this misuse, even though it has a relative \MARK{} rule.

\begin{lstlisting}[language=Java, caption=Part of a test case for the Cipher API from the Bouncy Castle tests, label={lst:partciphtestgen}, escapechar=|]
...
		Cipher cipher0 = Cipher.getInstance("RSA");
		cipher0.updateAAD(aadBytes);
		cipher0.doFinal(plainText, 0, 0, cipherText, 0); |\label{line:conscipher}|
...
\end{lstlisting}

In some cases, \codyze{} reports that a rule was violated and verified at the same time where there was no misuse, and we counted the violation as a false positive. For example, the listing \ref{lst:algorithmtestgen} shows one of the invalid test cases of AlgorithmParameterGenerator from Bouncy Castle tests. \codyze{} identifies a violation of a rule on Line \ref{line:notrandom} that states that the parameter \code{secureRandom0}, that was used in AlgorithmParameterGenerator was not generated by the SecureRandom API. This error is a false positive since the SecureRandom API was correctly used to generate a random number (\code{secureRandom0}). On the same line (Line \ref{line:notrandom}), \codyze{} identifies a rule verification that states that the \code{secureRandom0} was generated correctly with the SecureRandom API. This is in conflict with the previous misuse. This unusual behavior was also observed in several other test cases.
There is also the same violation and verification at Line \ref{line:repeatorder}, which is redundant. On Line \ref{line:repeatorder} of Listing \ref{lst:algorithmtestgen}, \codyze{} detected a violation against order because AlgorithmParameterGenerator was not properly terminated. It is a true positive, but in the Markers tab of Eclipse, this error had been displayed several times, which is unnecessary.



\begin{lstlisting}[language=Java, caption=One of the invalid test cases for the AlgorithmParameterGenerator API that \cognicrypttestgen{} generated from the original \crysl{} JCA ruleset., label={lst:algorithmtestgen}, escapechar=|]
	public void algorithmParameterGeneratorInvalidTest5() throws NoSuchAlgorithmException {

		SecureRandom secureRandom0 = SecureRandom.getInstance("DEFAULT");|\label{line:notrandom}|

		AlgorithmParameterGenerator algorithmParameterGenerator0 = AlgorithmParameterGenerator.getInstance("AES");
		algorithmParameterGenerator0.init(1048, secureRandom0); |\label{line:repeatorder}|

	}
\end{lstlisting}


Four \MARK{} policies did not function, and as a result, they did not report any violations or verifications. They were \MARK{} policies for the following APIs: DigestInputStream and DigestOutputStream, as well as CipherInputStream and CipherOutputStream. We checked for syntax issues in the relative files (entity and rule files), but there were no problems, and all of these policies were written the same as others and based on the instructions on \codyze's documentation page \cite{cod}. \codyze, however, detected misuses in two of those API's related test cases (i.e., numbers 4 and 5 of Table \ref{tab:bctestcomp}) that were related to other APIs. In the CipherInputStream and CipherOutputStream tests, \codyze{} found violations in the order of Cipher in all of the test cases (valid and invalid), which are true positives. It was the same error that appeared in Listing \ref{lst:ciphertestgen} Line \ref{line:wrongorder}, which indicated that the Cipher was not correctly terminated.

The results of analyzing JCA tests using \codyze{} with translated JCA \MARK{} rules and using \cognicryptast{} with JCA \crysl{} rules are shown in the Table \ref{appendix:jcatestcomp} in the appendices. There were fewer incorrect test cases in the JCA tests than in the Bouncy Castle tests. Therefore, the number of misuses that each tool detected in total was less in the JCA tests than in the Bouncy Castle tests. As a result, there were fewer dependent errors in the Cipher test cases in the JCA tests than in the Bouncy Castle tests. The number of misuses in Table \ref{appendix:jcatestcomp} is calculated without considering the dependant errors. If we count the dependent errors, the number of misuses \cognicryptast{} found in the valid Cipher cases will be 57 and in invalid 101. \codyze{} could not find some constraints errors in the JCA tests, as it did in the Bouncy Castle tests. Because the misuses found by each tool in the JCA tests are similar to those found in the Bouncy Castle tests, we will not discuss them again.


\subsubsection{Discussing the results of analyzing Bouncy Castle tests using \codyze{} with Bouncy Castle \MARK{} rules, and \cognicryptsast{} with the translated Bouncy Castle \crysl{} rules.}
\label{sec:testgenmarkbcresult}
We further analyzed the Bouncy Castle tests using \codyze{} with the Bouncy Castle \MARK{} rules and \cognicryptsast{} with translated Bouncy Castle \MARK{} rules. The results of the analyses are presented in Table \ref{tab:bctestcompmarkrules}. In Table \ref{tab:bctestcompmarkrules}, all column titles are the same as those in Table \ref{tab:bctestcomp} discussed in section \ref{sec:testgenbcresult}. TP refers to the number of true positives. An error is a true positive when it is caused by a violation of a \MARK{} rule or its translation to \crysl. FP is the number of false positives. An error is a false positive when no violation of the corresponding \MARK{} rule or its translation into \crysl{} has occurred.

In total, \codyze{} identified three types of misuses in the test - invalid or non-specified provider name, non- or incorrect padding for RSA Cipher, using the forbidden calls of SecureRandom API, and one invalid size of the key in the RSAKeyGenParameterSpec test case, all of which were true positives. \cognicryptsast{} identified all of those types of misuses but in fewer cases. \cognicryptsast{} generally found fewer misuses than \codyze. For example, in the Cipher tests (number 6 in Table \ref{tab:bctestcompmarkrules}), it appears that \cognicryptsast{} did not identify as many misuses as \codyze. This is because \cognicryptsast{} was unable to detect all of the provider misuses. The reason is the partial translation of the \MARK{} rules to \crysl. Not indicating a provider when using an API is considered a misuse, as stated in section \ref{sec:marktocrysl}. To translate this rule to \crysl, we must add the methods without a provider parameter to the FORBIDDEN section of the \crysl{} rule, which was not possible for all methods within an API. Therefore \cognicryptsast{} could not detect all the provider misuses. The same holds for SecureRandom forbidden calls. Since we could not add all the forbidden methods (see Listing \ref{lst:orgsecureRandomMARK} Lines \ref{line:forbidpbe1} and \ref{line:forbidpbe2}) in the FORBIDDEN section of SecureRandom \crysl{} rule; therefore, \cognicryptsast{} could not detect all forbidden calls.


As indicated in the Table \ref{tab:bctestcompmarkrules}, \codyze{} does not generate any false positives, while \cognicryptsast{} generates some false positives. In some tests, \cognicryptsast{} detects order misuses, which are all false positives. The order specified in the rules includes only optional usage of the methods, so any order is acceptable. Therefore, any order misuse generated by \cognicryptsast{} is a false positive. As an example, the false positives in the Mac tests in the valid and invalid test cases generated by \cognicryptsast{} are all caused by order misuses. \cognicryptsast generates order errors in Cipher, SecureRandom, Mac, and KeyAgreement test cases that are all false positives as described. An invalid order error can only be generated when using the Cipher API, with the Cipher mode being one of CCM, GCM, CBC, or CTR. This particular case requires specific method calls according to the \MARK{} Bouncy Castle rules. However, the Cipher mode was not specified in any of the Bouncy Castle test cases.


\cognicryptsast{} did not detect all the non- or incorrect padding for RSA Cipher misuses. Based on the Bouncy Castle \MARK{} rules, if an RSA Cipher is used without padding or with incorrect padding in the \code{getInstance} method of Cipher, this error should occur. This rule is defined as a constraint in the Cipher \crysl{} rule. \cognicryptsast{} can only find misuses of the parameters used within the EVENTS section. According to the \MARK{} rules, the \code{getInstance} method without a provider was considered insecure. However, this method could not be added to the FORBIDDEN section of the Cipher \crysl{} rule, as explained in Section \ref{sec:marktocrysl}. Therefore, \cognicryptsast{} does not detect RSA padding misuse.
Moreover, the other misuse of the RSAKeyGenParameterSpec API, regarding the incorrect size of the key, occurred in only one test case and was detected by both tools.



\begin{table}[H]
\centering
\setlength\tabcolsep{4.3pt} 
\small
\begin{tabularx}{\textwidth}{|P{0.5cm}|l|x|x|x|x|}
 \hline
 No.&Test Name & \makecell{Valid \\ tests} & \makecell{Invalid \\ tests} & \begin{tabular}{cccc}
    \multicolumn{4}{c}{\codyze{}} \\
    \multicolumn{2}{c}{Valid} & \multicolumn{2}{c}{Invalid}
    \\TP&FP& TP & FP
\end{tabular} & \begin{tabular}{cccc}
    \multicolumn{4}{c}{\cognicryptsast{}}\\
    \multicolumn{2}{c}{Valid} & \multicolumn{2}{c}{Invalid}\\
    TP&FP&TP&FP

\end{tabular}\\

 \hline
 \hline
1&AlgorithmParameterGenerator&  5 & 9 & 7{\hskip 0.25in}0 {\hskip 0.15in} 11 {\hskip 0.15in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 3 {\hskip 0.2in} 0\\
2&AlgorithmParameters& 9& 5& 13{\hskip 0.2in}0 {\hskip 0.15in} 5 {\hskip 0.2in} 0&2 {\hskip 0.2in}0 {\hskip 0.2in} 2 {\hskip 0.2in} 0\\
3&CertPathTrustManagerParameters& 1& 0& 1{\hskip 0.25in}0 {\hskip 0.15in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
4&CipherInputStream& 3& 5& 6{\hskip 0.25in}0 {\hskip 0.15in} 10 {\hskip 0.15in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
5&CipherOutputStream& 3&5 &6{\hskip 0.25in}0 {\hskip 0.15in} 10 {\hskip 0.15in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
6&Cipher& 56&69 & 164{\hskip 0.12in}0 {\hskip 0.12in} 177 {\hskip 0.1in} 0&8 {\hskip 0.2in}1 {\hskip 0.15in} 21 {\hskip 0.2in} 0\\
7&DHGenParameterSpec& 1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
8&DHParameterSpec&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
9&DigestInputStream&2&4 &2{\hskip 0.25in}0 {\hskip 0.2in} 4 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
10&DigestOutputStream&2&4 &2{\hskip 0.25in}0 {\hskip 0.2in} 4 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
11&DSAGenParameterSpec&2&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
12&DSAParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
13&ECGenParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
14&ECParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
15&GCMParameterSpec&2&0 &2{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
16&HMACParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
17&IvParameterSpec&2&0 &2{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}2 {\hskip 0.2in} 0 {\hskip 0.2in} 0 \\
18&KeyAgreement&7&23 &10{\hskip 0.2in}0 {\hskip 0.15in} 28 {\hskip 0.15in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 5 {\hskip 0.2in} 1 \\
19&KeyFactory&6&0 &10{\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&3 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
20&KeyGenerator&8&8 &11{\hskip 0.2in}0 {\hskip 0.15in} 11 {\hskip 0.15in} 0&2 {\hskip 0.2in}0 {\hskip 0.2in} 2 {\hskip 0.2in} 0\\
21&KeyManagerFactory&6&4 &6{\hskip 0.25in}0 {\hskip 0.15in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
22&KeyPairGenerator&6&10 &6{\hskip 0.25in}0 {\hskip 0.15in} 10 {\hskip 0.15in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 3 {\hskip 0.2in} 0\\
23&KeyStoreBuilderParameters&1&0 &0{\hskip 0.25in}0 {\hskip 0.15in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
24&KeyStore&13&21&13{\hskip 0.2in}0 {\hskip 0.17in} 21 {\hskip 0.15in} 0&4 {\hskip 0.2in}0 {\hskip 0.2in} 6 {\hskip 0.2in} 0\\
25&Mac&12&21 &27{\hskip 0.2in}0 {\hskip 0.15in} 35 {\hskip 0.15in} 0&0 {\hskip 0.2in}1 {\hskip 0.2in} 0 {\hskip 0.2in} 2\\
26&MessageDigest&9&13 &9{\hskip 0.25in}0 {\hskip 0.15in} 13 {\hskip 0.15in} 0&2 {\hskip 0.2in}0 {\hskip 0.2in} 3 {\hskip 0.2in} 0\\
27&MGF1ParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
28&OAEPParameterSpec&1&0 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
29&PBEKeySpec&1&1 &1{\hskip 0.25in}0 {\hskip 0.2in} 1 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
30&PBEParameterSpec&2&0 &2{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
31&PKIXBuilderParameters&2&0 &1{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
32&PKIXParameters&2&0 &1{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
33&RSAKeyGenParameterSpec&1&0 &1{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&1 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
34&SecretKeyFactory&3&2 &5{\hskip 0.25in}0 {\hskip 0.2in} 2 {\hskip 0.2in} 0&1 {\hskip 0.2in}1 {\hskip 0.2in} 1 {\hskip 0.2in} 0\\
35&SecureRandom&38&16 &71{\hskip 0.17in}0 {\hskip 0.15in} 19 {\hskip 0.15in} 0&10 {\hskip 0.15in}1 {\hskip 0.2in} 4 {\hskip 0.2in} 2\\
36&SSLContext&5&5&5{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
37&SSLParameters&4&4 &0{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
38&TrustManagerFactory&6&4 &6{\hskip 0.25in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0&0 {\hskip 0.2in}0 {\hskip 0.2in} 0 {\hskip 0.2in} 0\\
 \hline
 \hline
 \multicolumn{2}{|l|}{ \textbf{Total}} &  \textbf{228} & \textbf{233} & 390 {\hskip 0.05in} 0{\hskip 0.2in} 361 {\hskip 0.15in}0 &  36{\hskip 0.15in} 6{\hskip 0.2in} 50{\hskip 0.2in} 5\\
 \hline
  \multicolumn{2}{|l|}{\multirow{2}{*}{\textbf{Results}}}
 &   \multicolumn{2}{|l|}{\textbf{Precision(\%)}} &100 & 88,65\\ 
 
 \multicolumn{2}{|l|}{} & \multicolumn{2}{|l|}{\textbf{Recall(\%)}} & 100 & 11,45 \\
 \hline

\end{tabularx}
\caption{\label{tab:bctestcompmarkrules} Comparison of the results of \codyze{} and \cognicryptsast{} analyses with \MARK{} rules of Bouncy Castle tests generated by \cognicrypttestgen.}
\end{table}


To summarize, \cognicryptsast{} provided better precision and recall than \codyze{} in analyzing the Bouncy Castle and JCA tests; however, both tools performed well in general. Nevertheless, when comparing errors relating to order misuses, \codyze{} performs better than \cognicryptsast.

The \cognicryptsast{} with translated \crysl{} rules did not perform well in identifying the misuses based on \MARK{} rules. According to Table \ref{tab:bctestcompmarkrules}, \cognicryptsast{} only found 11 percent of the misuses. This could indicate that \MARK{} is a more expressive DSL than \crysl. \cognicrypttestgen{} generated tests, however, did not cover all sections of the \crysl{} rules. To determine whether all translated \MARK{} rules deliver the same performance as the \crysl{} rules, we need a benchmark that covers all vulnerabilities related to all parts of the \crysl{} rules.

In addition, the rules defined by \MARK{} in the Bouncy Castle ruleset did not address many of the cryptographic vulnerabilities we know today, such as the use of non-random keys in encryption. The available \crysl{} rules, in contrast, cover many known vulnerabilities. By analyzing the test cases generated by the \crysl{} rules using translated \MARK{} rules in \codyze, we were able to understand how \codyze{} would perform with the new rules that define more vulnerabilities. 


Although the test cases generated by \cognicrypttestgen{} did not cover all sections of the \crysl{} rules, they still contain many vulnerabilities that detecting them could be very useful. Notably, the test cases included parts of the \crysl{} rules that could be translated to mark. Thus, we expected \codyze{} to be similar to \cognicryptsast{} in terms of rules. However, after the analysis, we discovered that some rules behave strangely, and some constraint rules do not work. Additionally, a few \MARK{} policies did not function at all. The results also showed that \cognicryptsast{} could not detect all order misuses and, in some cases, find order misuses that are false positives.

