To summarize the previous chapter, \codyze{} \cite{cod} and \cognicryptsast{} \cite{stefanphd} are static analyzers for security testing that analyze the program to find cryptographic misuses. \codyze{} and \cognicryptsast{} consume \MARK{} \cite{cod} and \crysl{} \cite{skm19} rules respectively to perform the analysis. \MARK{} and \crysl{} are both DSLs for specifying the correct usages of cryptographic APIs. We can divide the theoretical comparison of \codyze{} and \cognicryptsast{} into two parts, graph generation and how each tool analyzes the constructed graphs against the rules. Based on the information we provided on each tool on Chapter \ref{ch:intro}, we will compare them closely in analysis and graphs.

\subsection{Comparison of the graphs}
As we discussed in the previous chapter (cf. Chapter \ref{ch:intro}), both tools convert the source code into an intermediate representation in order to facilitate and speed up the analysis process. \codyze{} converts the source code into a graph representation (CPG), and \cognicryptsast{} transforms the source code into a Soot IR (Jimple), and then builds a call graph of the program or combines individual CFGs and the programâ€™s call graph into an ICFG.

The CPG is explicitly designed to identify vulnerabilities in large amounts of source code efficiently and effectively \cite{cpg}. CPG can be generated of an erroneous code. Therefore, \codyze{} can analyze incomplete source codes and tolerate minor syntax errors \cite{cod}. The CPG can either be used manually with a query language (e.g., NQL, SQL, or Gremlin) to identify the relevant patterns or automatically when integrated into CI/CD or IDEs \cite{cod}. CPGs are independent of programming languages. When a program with a specific programming language is translated into a CPG, any query written for any other programming language can also apply to this CPG. Consequently, \codyze{} is capable of analyzing C and C++ programs as well as Java programs.
The Code Property Graph (CPG) combines many representations of source code into one queryable graph database. This enables the CPG to understand the full flow of information across an application (AST) and represents the order in which statements are executed (CFG), and detects flaw injections or leaks of sensitive information (PDG). As a result, \codyze{} is a flow-sensitive data-flow analysis. CPG does not address inter-procedural analysis; however, it can be enhanced with call edges to provide inter-procedural analysis as shown in the study by Backes \etal \cite{cpgphp}.

% However, the order of operations cannot be analyzed with only the query language, therefore codyze developers implemented a typestate analysis for that matter. The valid typestates are determined by regular expression in the MARK "order" construct (see Listing \ref{lst:keygenmarkruletrans} Line \ref{line:ordermark}).


\cognicryptsast{} first parses the programs into an IR (Jimple) using Soot \cite{soot} and then constructs a call graph for it. IRs generally cover a limited number of constructs to analyze a program while still expressing all language elements. These limits simplify analysis by reducing the number
of cases that analysis must cover. This leads to a simpler call graph. Call graphs show an abstraction of all method calls in a program that could be used for further analysis. In addition to call graphs, \cognicryptsast{} constructs CFGs of individual statements and sometimes creates an ICFG to represent the whole program. A similar approach applies to analyzing Android programs intra-procedurally. Moreover, the FlowDroid \cite{flowdroid} extension allows the creation of Android-specific call graphs that can be used to construct the ICFG and perform inter-procedural analysis.
% valid typestates are same as mark determined by regular expression in the ORDER section of the crysl rules (see Listing \ref{lst:orgkeygencrysl} line \ref{line:ordercrysl})

% In this thesis we will chose the CHA call graphs the default algorithm for evaluating cognicryptsast 
% (cf. \ref{ch:eval}) cause although it is not precise but is efficient and is context sensitive.
Currently, Soot only accepts Java code as an input to make IR, and therefore, \cognicryptsast{} cannot analyze other languages since it lacks the required IR. According to the readme file of the Soot Github repository \cite{sootgit}, Soot can process Java code up to Java 9. However, the Soot documentation page has not been updated and indicates that it only supports Java code up to Java 7 \cite{soot}. \cognicryptsast{} have not been modified yet to use the most recent version of Soot and can only work with Java source code up to Java 8, and cannot analyze programs with Java versions higher than Java 8.


The graph construction is the most time-consuming part of the analysis in \cognicryptsast. According to \cite{skm19}, the majority of the total analysis time (83\%) is spent on call graph construction in analyzing 8,422 apps by \cognicryptsast{}. There are no publications or resources available to illustrate the time required to generate a CPG in \codyze{}, except for a presentation \cite{presentationcodyze} which included statistics of a \codyze{} analysis of 338 KB C++ source codes (12K lines of code and 486 methods). Based on their calculations, the CPG conversion time was 2.7 seconds or approximately 6 percent of the total analysis time. The results are unreliable to predict how much time will be required to construct a CPG on average. For this purpose, we would need to generate CPG for a significant number of programs to provide an accurate estimate. Upon further research on the CPG, we discovered that Backes \etal{} \cite{cpgphp} generated CPGs with the call edges of 1,854 projects in their study. The results show that the AST generation of all projects took 40 minutes and 30 seconds, and the CFG, PDG, and call edge generations took 5 hours 10 minutes 33 seconds. However, this does not provide a reasonable estimate of how long it takes to generate a CPG since they did not create a pure CPG. We could further calculate the average time it takes to create a CPG using \codyze{} by analyzing several benchmarks and calculating the time required to create the CPG. This, however, was beyond the scope of our thesis as it involved a few modifications to \codyze's source code, which would require some time and, therefore, exceed our time limits. We will discuss it further in the further work chapter (cf. Chapter \ref{ch:fwork}).

CPG is more complex and sophisticated than CG. \codyze{} extracts most of the analysis information directly from the CPG with the help of a query language to verify that it complies with the \MARK{} rules, whereas \cognicryptsast{} performs three different analyses on the call graph to determine whether it complies with the \crysl{} rules (cf. chapter \ref{ch:intro}). Using only the query language is not sufficient for analyzing the order of operations in \codyze. Therefore, \codyze{} developers have implemented a typestate analysis for this purpose. We will discuss this in the next section (Section \ref{sec:comanalysis}).

In order to determine which approach is more precise and effective, we will compare the results of the analysis performed by each tool with the same rules (same API specifications but with different DSLs) and the same source code in the Evaluation chapter (cf. Chapter \ref{ch:eval}). 

\subsection{Comparison of the analysis of the graphs}
\label{sec:comanalysis}
In the previous section, we discussed the graphs and the intermediate representations of the source code that each tool generates. In this section, we will examine the analyses that \codyze{} and \cognicryptsast{} perform on the IRs in order to identify cryptographic misuses in the program. As mentioned in the Chapter \ref{ch:intro}, \codyze{} and \cognicryptsast{} examine the code against the written \MARK{} and \crysl{} rules, respectively. Both tools have parsers that convert the rules into models that the respective analysis can use.

According to Kreuger \cite{stefanphd}, they have developed a parser for translating \crysl{} rules into the \crysl{} object model. \cognicryptsast{} transforms the rules in the \crysl{} object model into a static data-flow analysis that is both flow- and context-sensitive. \cognicryptsast{} contains a typestate analysis to validate the order in which the operations are called, a Boomerang instance to check the parameters against the \crysl{} rules, and a taint analysis for flaw injections and information leakage in Android applications. The analysis automatically examines Java or Android applications that have been converted into Jimple to determine whether they conform to the encoded \crysl{} rules. The error message that \cognicryptsast{} generates in the event of a misuse depends on the type of misuse and the factors that led to the misuse. There are several types of misuses that we named in Section \ref{sec:cc}. 

\codyze{} converts the \MARK{} rules into a \MARK{} model that the analysis can use. \codyze{} utilizes CPG and query language to analyze a program's data flow and detect information leaks. In \codyze, the order of operations cannot be analyzed with only the query language; as a result, \codyze{} developers implemented a typestate analysis in that regard. \codyze{} error messages are derived from a JSON file created by \codyze{} maintainers (see Section \ref{sec:codyze}), with the exception of order and forbidden call violations. Error messages related to those violations are generated automatically at \codyze's runtime.


Both tools utilize typestate analysis to provide flow sensitivity to ensure that the order of operations in the source code complies with the \MARK{} or \crysl{} rules. Nevertheless, \cognicryptsast{} employs IDE\textsuperscript{al} \cite{IDEal}, a framework for inter-procedural data-flow analysis, in order to perform a typestate analysis. The analysis defines a finite-state machine from the ORDER section of the \crysl{} rule to verify an object's trace in the program. It also defines the allocation sites from which to begin the analysis. An allocation site is a point at which an object is created in an object-oriented program. IDE\textsuperscript{al} performs a flow-, field-, and context-sensitive typestate analysis from those allocation sites. Because C is not an object-oriented language, and C++ is not an entirely object-oriented language, this typestate analysis cannot be used to analyze C programs or all C++ programs.

\codyze, on the other hand, uses a Weighted Pushdown System (WPDS) \cite{pushdown} for typestate analysis. The WPDS presents an abstraction of the data flows within a program. Currently, there is one WPDS per function in \codyze; therefore, it is not inter-procedural. Nonetheless, when evaluating the performance of \codyze, we realized that it is partially inter-procedural. We will discuss it in Chapter \ref {ch:eval}. The typestates are specified by a regular expression in the \MARK{} \code{order} construct. The analysis converts the regular expression into a Non-deterministic Finite Automaton (NFA). The finite automata are called NFA when there exist many paths for specific input from the current state to the next state. Typestate NFA transitions are then represented as weights for a WPDS. This typestate can be used for non-object-oriented programs such as C.

In both tools, valid typestates are determined by regular expressions in the rules. In \crysl, regular expressions are defined in the ORDER section (see Listing \ref{lst:orgkeygencrysl} Line \ref{line:ordercrysl}) and in \MARK, the order construct (see Listing \ref{lst:keygenmarkruletrans} Line \ref{line:ordermark}).

Although we have an understanding of the differences in the implementation of analyzers of both tools, we will only be able to determine the effectiveness of each approach in an evaluation. We, therefore, will perform an evaluation in Chapter \ref{ch:eval}.

