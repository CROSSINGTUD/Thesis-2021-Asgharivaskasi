Protecting sensitive data is an essential part of software development. Nowadays, businesses, governments, hospitals, and many other organizations use software for transporting or storing their data, and they can experience huge complications from having sensitive information exposed. Financial loss, legal issues, or in some cases, loss of lives are some of the consequences of poor or lack of security in the software development process. Therefore, it is essential to have proper security in the application. Cyberattacks are inevitable problems; the costs of recovering from an attack can be high and impact the company or individual; however, it can be avoided by using cryptography in the software development process.

Cryptography is a method of information protection and secure communication so that only those who are supposed to read and process it can do so. Using cryptography correctly can reduce security vulnerabilities in code. There are some cryptographic algorithms that can help to add security to the application, and these algorithms have been implemented in Application Programming Interfaces (API) libraries. Cryptographic APIs offer cryptography in different usecases, like data encryption, secure communication, authentication, and other cryptographic use cases. The Java Platform provides Java Cryptographic Architecture (JCA) \cite{jca} which is a set of APIs for implementing cryptography in Java. Listing \ref{lst:codesample} shows simple message encryption with the use of javax.crypto.Cipher \cite{cipher}. The method gets a message and a secret key as parameters, then encrypts the message using the key and returns the result.

\begin{lstlisting}[language=Java, caption=Sample code of message encryption using Cipher object., label={lst:codesample}, escapechar=|]
public class EncryptionSample {
	   public static byte[] main(byte[] message, SecretKey key) throws Exception{
	      Cipher cipher = Cipher.getInstance("DES");|\label{line:des}|
	      cipher.init(Cipher.ENCRYPT_MODE, key);
	      cipher.update(message);
	      byte[] cipherText = cipher.doFinal();
	      return cipherText;
	   }
	}
\end{lstlisting}
The sample code does not raise a syntactical error. However, it contains misuses that make the program vulnerable. For example, this sample code uses the DES\footnote{Data Encryption Standard} algorithm to encrypt the data. DES was found to be vulnerable to attacks like brute-force. A brute force attack involves guessing login information, encryption keys, or locating a hidden web page through trial and error. Attackers try all possible combinations in the hopes of making the right guess. Therefore, DES is considered insecure, so it is better to use an alternative algorithm, such as AES\footnote{Advanced Encryption Standard}. AES is a more mathematically efficient and elegant algorithm for data encryption, since it supports block lengths of 128 bits while DES provides only 64 bits of block length. In addition, AES provides key lengths of 128 bits, 192 bits, or 256 bits while DES provides only 56 bits. When using cryptographic APIs, developers should know well how to integrate them into their codes. Otherwise, incorrect usages of these APIs would result in insecurity in the program. Lazar \etal{}  \cite{dlz14} investigated 269 cryptography-related vulnerabilities. In only 17\% of the cases, the problem was in cryptographic libraries themselves, where the other 83\% were developers misusing cryptographic APIs. Another study on cryptography usage in Android applications suggests that approximately 90\% of the applications contain at least one misuse \cite{cx16}. Developers often struggle with using cryptographic APIs. Studies show that developers find APIs too intricate \cite{snb16}. In addition to Oracle's documentation on cryptographic APIs \cite{jca}, developers also use the help of web pages like Stack Overflow\footnote{\url{https://www.stackoverflow.com/}}. The information provided on these websites is generated by regular developers who may not have crypto expertise \cite{asw}. Furthermore, some classes have multiple methods with different possible parameters (some would be deprecated or insecure to use). When using a combination of them, establishing the correct implementation would be very difficult and confusing. Nadi \etal{} \cite{snb16} researched why developers find it challenging to use cryptographic APIs. The majority of participants had Java development experience (73\%), and 86\% had at least minimum knowledge of cryptography. The study showed that inadequate documentation with no examples and complicate API design that makes it hard for developers to apply them were the main reasons. When asked for suggestions, the participants wished for solutions to improve cryptography use in Java, like better documentation, new API styles, and more tool support.

Several tools are made to detect misuses of Java cryptographic APIs through static analysis, the method of analyzing the source code without executing the program. Various techniques exist in developing static analysis tools for finding cryptographic misuses \cite{emp13, bin18, sr19, skm19, cod}. For example, \cryptoguard{} \cite{sr19} is a static analyzer that analyzes massive-sized Java projects for detecting cryptographic and SSL/TLS API misuses using a program slicing approach. Program slicing is a method for simplifying the programs by concentrating on particular elements of semantics and eliminating non-essential parts. The Related work chapter provides an overview of some examples of analyzers (cf. Chapter \ref{ch:relatedwork}).

Among those tools, \cognicryptsast{} \cite{skm19} and \codyze{} \cite{cod} stand out because they seem to have similar approaches. \cognicrypt{} is a platform with two components that aid in the proper use of cryptographic APIs in Java. \cognicryptgen{} generates code examples for cryptographic APIs, and \cognicryptsast{} is a static analyzer for finding cryptographic misuses in Java programs. \codyze{} is also a static analysis tool that analyzes Java or C++, or C programs to verify the correct implementation of cryptographic APIs. They both use a white-listing approach, where proper uses of cryptographic APIs are defined in specifications written in domain-specific languages (DSL), \crysl{} \cite{skm19}, and \MARK\footnote{\url{https://www.codyze.io/docs/}}, respectively. Domain-specific languages are designed to perform specific tasks within a particular domain \cite{dslwhen}, in this case, to define rules for cryptographic API usage. 

As it seems on an abstract level, their approaches seem similar. However, if we look into more details and explore their implementations closely, we find several differences. As we mentioned earlier, both of them use white-listing approaches and define rules for usages of Java cryptographic APIs, which specify how each class should be used in order to make a secure program. However, they use different DSLs for that purpose. In addition, the way each tool examines the source code against those rules is different. Therefore, it is interesting to look further into them to discover where the similarities and differences lie and explore the advantages of these differences. This thesis compares these two tools in terms of DSLs, analysis techniques, performances, and their capabilities. Our results demonstrate the strengths and weaknesses of each tool. We can use this information to improve the tools in the future and create more reliable and efficient analyzers.

This thesis is structured as follows: Chapter \ref{ch:relatedwork} describes the related tools that can detect cryptography misuses in a program. Chapter \ref{ch:intro} presents an overview of \codyze{} and \cognicryptsast. In Chapter \ref{ch:compare}, we compare the two tools and their respective DSLs both theoretically and practically. Chapter \ref{ch:eval} provides an evaluation of the tool's performance using two benchmarks and discusses the findings. Chapter \ref{ch:conclusion} concludes this thesis, and finally, Chapter \ref{ch:fwork} describes future actions that can be taken to compare more aspects of the tools and to improve the quality of the tools.
