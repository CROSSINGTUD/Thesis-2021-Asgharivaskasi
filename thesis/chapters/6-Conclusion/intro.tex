\chapter{Conclusion}
\label{ch:conclusion}
In this thesis, we compared two static analysis tools, \codyze{} and \cognicryptsast, that use white-listing approaches to detect misuse of cryptographic APIs in order to identify their similarities and differences. They are both capable of analyzing Java programs to detect misuses of Java cryptographic APIs, and \codyze{} can also analyze C and C++ programs. Both tools employ rules written in domain-specific languages that specify the proper usages of the cryptographic APIs. \codyze{} uses \MARK{} rules, and \cognicryptsast{} uses \crysl{} rules. Moreover, both tools convert the source code into a graph representation for analysis. 

The theoretical comparison (see Section \ref{sec:theotools}) of the tools was based on examining published papers, documentation pages, and source code for each tool. 
Based on the theoretical comparison, we have concluded that both tools are flow-sensitive data-flow analyses. However, \cognicryptsast{} analysis is also context- and field-sensitive and inter-procedural, whereas \codyze{} analysis is intra-procedural.
Nevertheless, when evaluating the performance of \codyze{} and \cognicryptsast{} with \cryptoapibench{} (see Section \ref{sec:apibench}), we discovered that \codyze{} detects misuses in 20 inter-procedural test cases out of 22 vulnerable test cases and is therefore partially inter-procedural. To check whether \codyze{} is entirely inter-procedural or not, we need more inter-procedural test cases. Furthermore, \cryptoapibench{} does not provide context-sensitive test cases to check the context sensitivity of the tools. Generally, the number of test cases was limited and may not provide a reliable indication of the analysis properties of each tool; therefore, we require more test cases that cover different aspects of analysis to examine the tool's analysis properties in the future.

\cognicryptsast{} converts source code to a Soot IR, Jimple, and constructs call graphs of Jimple code. Therefore, \cognicryptsast{} can only analyze Java and Android programs since Soot does not support other programming languages than Java.
In contrast, \codyze{} generates CPGs from the source code and writes queries to retrieve data from the CPG. Since CPGs are independent of the programming language, \codyze{} can analyze programs in several programming languages with the same queries. Currently, \MARK{} rules are available for Java, C, and C++, and \codyze{} is capable of analyzing C, C++, Java, and Android programs.

Further, we performed a comparison of the \MARK{} and \crysl{} DSLs in order to determine which DSL is more expressive in specifying correct usages of the Java cryptographic APIs (see Section \ref{sec:dsl}). We translated the Bouncy Castle JCA and JCA \crysl{} rules to \MARK, and since there were only \MARK{} rules for the Bouncy Castle API, we translated the \MARK{} Bouncy Castle ruleset to \crysl. We realized that \crysl{} and \MARK{} express different things; however, they also have commonalities. Therefore, some parts of the rules of each DSL cannot be translated from one to another. For example, the ENSURES section of \crysl{} rules or the unspecified provider rules in \MARK. Thus the translations do not entirely represent the original rules. Although, as part of our future work, it might be possible to include several built-in functions in both DSLs that will enable us to translate the entire contents of one language to another. Additionally, we discovered that \crysl{} sections are designed to be related, but the \MARK{} rules are independent of each other, making it more flexible to write rules. This flexibility may make \MARK{} more challenging to use, and this could be determined by conducting a user study for the use of the \crysl{} and \MARK{} DSLs. As a user study is outside the scope of our thesis, it could be done as future work. Moreover, the results of rule translation indicated that when specifying the same rules for an API, \MARK{} rules occupy more space than \crysl{} rules. Because, for every rule in \MARK, we need to specify its structure, which consists of a name, a condition, a precondition, and a message on failure. While in \crysl, we only add the condition and precondition to the relative section.

We further evaluated the tools with two benchmarks, \cryptoapibench{} and test cases generated by \cognicrypttestgen. Analyzing \cryptoapibench{} showed that \codyze{} had better precision than \cognicryptsast{} in finding misuses, but \cognicryptsast{} covered more vulnerabilities. We also discovered that \cognicryptsast{} is partially field-sensitive and rarely path-sensitive. However according to the theoretical comparison, \cognicryptsast{} is field-sensitive but not path sensitive. Additionally, we noticed that \codyze{} is partially field-sensitive and, contrary to what we discovered in the theoretical comparison, is partially inter-procedural. \cryptoapibench{} only includes a few test cases for each case, and also, the test cases could be incorrect or biased toward \cryptoguard. Therefore, to ensure the analysis properties of the tools, we need to analyze more test cases that we plan to do in the future.
Lastly, the error messages that \cognicryptsast{} and \codyze{} generated for the same cryptographic vulnerability were different. By conducting a user study in the future, we may determine which one is preferred by users.

Moreover, we generated test cases with \cognicrypttestgen{} using the Bouncy Castle JCA, JCA \crysl{} rules, and translated Bouncy Castle \crysl{} rules (see Section \ref{sec:testgen}). Some test cases generated from the translated Bouncy Castle \crysl{} rules contained compiler errors. However, \codyze{} found two misuses in those faulty test cases, which were true positives, but \cognicryptsast{} could only find those misuses after we fixed the faulty test cases. This illustrates \codyze's capability to analyze uncompilable codes. In analyzing Bouncy Castle JCA and JCA tests, we used the translated \MARK{} rules in \codyze. Results showed that \codyze{} performed better than \cognicryptsast{} in finding order misuse; however, in general, the performance of \cognicryptsast{} was better than \codyze{} in terms of precision and recall. \codyze{} was unable to detect some constraint misuses, and certain \MARK{} policies did not work at all. In addition, we used translated Bouncy Castle \crysl{} rules and Bouncy Castle \MARK{} rules to analyze the Bouncy Castle tests. Based on the results, \cognicryptsast{} could only detect 11\% of the misuses defined by the Bouncy Castle \MARK{} rules. This is due to the partial translation of \MARK{} to \crysl.  Currently, it is not possible to include all types of methods in the FORBIDDEN section of the \crysl{} rule. Further, the restrictions defined in the CONSTRAINTS section are only valid for parameters used in the EVENTS section. Thus, \cognicryptsast{} was unable to detect some misuses.

According to our results, \codyze{} and \cognicryptsast{} performed very similarly; however, some aspects of both tools and their respective DSLs could be improved. There should be more \MARK{} and \crysl{} rules to address more cryptographic vulnerabilities. \crysl{} and \MARK{} could have more or enhanced built-in functionality to specify rules more effectively and efficiently. The tools sometimes fail to detect misuse in a program that uses an API incorrectly, despite having rules for the relative API, which also requires correction. Also, we obtained information about the tools' analysis properties, as described above, which also needs further investigation that we will present in the future work chapter (cf. Chapter \ref{ch:fwork}).